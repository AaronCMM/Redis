<img src="https://i.loli.net/2021/05/03/xyLUhvRasfdKNz4.jpg" alt="img" style="zoom: 18%;" />

Redis 使用哈希表来存储所有的键值对。

哈希桶中的 entry 元素中保存了 key 和 value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 value 指针被查找到。

<img src="https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg" alt="img" style="zoom: 33%;" />

##### 问题：

​	整数数组 和 压缩列表 在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

==两方面原因：==

1、内存利用率，**数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少**。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，**提高内存的利用率**。

2、**数组对CPU高速缓存支持更友好**，所以Redis在设计时，集合数据元素较少情况下，**默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度**。当**数据元素超过设定阈值**后，避免查询时间复杂度太高，**转为哈希和跳表数据结构存储**，保证查询效率。



### 为什么单线程的 Redis 能那么快？

Redis 是单线程的意思是：<font color=red>Redis 的网络 IO 和键值对读写是由一个线程来完成的</font>，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

#### 多线程的开销

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。

通常情况下，在我们采用多线程后，如果没有良好的系统设计，实际得到的结果，其实是右图所展示的那样。我们刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

<img src="https://static001.geekbang.org/resource/image/cb/33/cbd394e62219cc5a6d9ae64035e51733.jpg" alt="img" style="zoom:30%;" />



<font color=red>**关键的瓶颈在于**</font>，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当**有多个线程要修改这个共享资源**时，为了保证共享资源的正确性，就需要有**额外的机制进行保证**，而这个额外的机制，就会**带来额外的开销**。**==多线程编程模式面临的共享资源的并发访问控制问题。==**

并发访问控制一直是多线程开发中的一个难点问题，**如果没有精细的设计，**比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：**即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加**。而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。**为了避免这些问题，Redis 直接采用了单线程模式。**

#### 单线程 Redis 为什么那么快？

- 一方面，<font color=red>**Redis 的大部分操作在内存上完成**</font>，再加上它采用了**高效的数据结构**，例如哈希表和跳表，这是它实现高性能的一个重要原因。
- 另一方面， <font color=red>**Redis 采用了多路IO复用机制**</font>，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。接下来，我们就重点学习下多路复用机制。

<img src="https://i.loli.net/2021/05/04/nJE1KcG3f9DSVvt.jpg" alt="img" style="zoom:20%;" />

Redis IO 多路复用机制： 

1. 基于linux select/epoll 。
2. 内核可同时监听多个监听套接字和 多个已连接套接字 。
3. 一旦内核监听到套接字上有数据返回，立刻交给redis线程处理数据。

##### 总结：

<font size=4>**Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题**</font>。单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。

<font size=4 color=blue>问题：</font>

- redis真的只有单线程吗？
  - 单线程是指网络IO 和数据读写操作是由一个线程完成的。**数据清理，持久化，主从复制也使用到了其他线程。** 

- 为什么使用单线程？ 
  - 避免多线程开发的并发控制问题，且多线程开发代码复杂，可维护性差。 
- 单线程为什么这么快？ 
  - 内存+高效的数据结构+IO 多路复用

##### 有哪些潜在的性能瓶颈吗？

- <font color=blue>任意一个请求在server中一旦发生耗时，都会影响整个server的性能</font>，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：
  - **操作bigkey**：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；
  - 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
  - **大量key集中过期：Redis的过期机制也是在主线程中执行的**，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
  - **淘汰策略：淘汰策略也是在主线程执行的**，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
  - **AOF刷盘开启always机制**：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
  - **主从全量同步生成RDB**：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
- **并发量非常大时，单线程读写客户端IO数据存在性能瓶颈**，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，**只能单线程依次读取客户端的数据，无法利用到CPU多核。**

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了**lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。**

**针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据**，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。



### AOF 日志是如何实现的？

传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。

##### AOF 为什么要先执行命令再记日志呢？

为了避免额外的检查开销**，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查**。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。（可以避免出现记录错误命令的情况；不会阻塞当前的写操作。）

##### AOF 的写回策略

<img src="https://i.loli.net/2021/05/04/2xnAm8fLIbuyNEc.jpg" alt="img" style="zoom:25%;" />

<font color=red>总结一下就是</font>：想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择 Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。

<font size=4>三种写回策略体现了系统设计中的一个重要原则 ，即<font color=red> trade-off</font>，或者称为“取舍”，指的就是在性能和可靠性保证之间做取舍。</font>

##### 日志文件太大了怎么办？（AOF重写机制）

**AOF 重写机制。**AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，**记录键值对的最终状态**，**从而实现对 某个键值对 重复操作后产生的多条操作记录压缩成一条 的效果**。进而实现压缩AOF文件的大小。

##### AOF 重写会阻塞吗?

**和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的**，这也是为了避免阻塞主线程，导致数据库性能下降。

“一个拷贝，两处日志”。

“一个拷贝”是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。

因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志；第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作

<img src="https://i.loli.net/2021/05/04/89DMhHxYOVXtvr3.jpg" alt="img" style="zoom:20%;" />

<font color=red>总结来说</font>，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 **Redis 采用额外的线程进行数据重写**，所以，这个过程并不会阻塞主线程。

##### 问题：

- <font color=blue>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？</font>
  - AOF重写不复用AOF本身的日志，一个原因是**父子进程写同一个文件必然会产生竞争问题**，控制竞争就意味着会影响父进程的性能。**二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用**。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。

### 内存快照 RDB

<font color=red>写时复制，保证快照期间数据可修改。</font>

<img src="https://i.loli.net/2021/05/04/64EZMloYh8TbU2u.jpg" alt="img" style="zoom:15%;" />

bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，**如果主线程要修改一块数据**（例如图中的键值对 C），那么，**这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件**，而在这个过程中，主线程仍然可以直接修改原来的数据。

##### 可以每秒做一次快照吗？

- 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
- bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，**fork 这个创建过程本身会阻塞主线程，**而且主线程的内存越大，阻塞时间越长。

<font color=red>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法</font>。简单来说，<font size=4>**内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作**。</font>

内存快照和AOF混合使用：

<img src="https://static001.geekbang.org/resource/image/e4/20/e4c5846616c19fe03dbf528437beb320.jpg" alt="img" style="zoom:20%;" />

##### 问题

- 2核CPU、4GB内存、500G磁盘，Redis实例占用2GB，写读比例为8:2，此时做RDB持久化，有什么风险吗？

答：产生的风险主要在于 CPU资源 和 内存资源 这2方面：

a、内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，**“写实复制”会重新分配整个实例80%的内存副本**，大约需要重新分配1.6GB内存空间，这样**整个系统的内存使用接近饱和**，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。

### 主从库如何实现数据一致？

学习了 AOF 和 RDB，如果 Redis 发生了宕机，它们可以分别通过回放日志和重新读入 RDB 文件的方式恢复数据，从而保证尽量少丢失数据，提升可靠性。

##### Redis 的高可靠性

- 数据尽量少丢失。
- **服务尽量少中断。**

AOF 和 RDB 文件保证了前者，对于后者，Redis 的做法是，**增加副本冗余余量**。

<font color=red>Redis 主从库和读写分离：</font>

<img src="https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg" alt="img" style="zoom: 18%;" />

使用读写分离，对于写操作，首先在主库执行，然后主库将写操作同步到从库。这么做 的原因在于，不需要涉及到 加锁、实例间协商是否完成修改等系列操作。

#### 主从库间如何进行第一次同步？

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系。

<img src="https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="img" style="zoom:18%;" />

FULLRESYNC 响应表示**第一次复制采用的全量复制**，主库会把当前所有的数据都复制给从库。在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。

**主库执行 bgsave 命令，生成 RDB 文件**，生成一个子进程，将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。为了保证主从库的数据一致性，主库会在内存中用专门的 **replication buffer，记录 RDB 文件生成后收到的所有写操作。**

#### 主从级联模式分担全量复制时的主库压力

一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。**如果从库数量很多**，而且都要和主库进行全量复制的话，**就会导致主库忙于 fork 子进程**生成 RDB 文件，进行数据全量同步。**fork 这个操作会阻塞主线程**处理正常请求

通过<font color=red>“主 - 从 - 从”模式</font>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。

<img src="https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg" alt="img" style="zoom:15%;" />

#### 主从库间网络断了怎么办？

当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。

<font color=red>repl_backlog_buffer 是一个环形缓冲区（全局共享）</font>，主库会记录自己写到的位置，从库会记录自己已经读到的位置。

<img src="https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg" alt="img" style="zoom:15%;" />

**主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库**；主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距，并进行增量复制。

**如果从库的读取速度比较慢**，就有可能导致**从库还未读取的操作被主库新写的操作覆盖了**，这会导致主从库间的数据不一致。（此时会变成，**全量复制**）；要想办法避免这一情况，一般而言，我们**可以调整 repl_backlog_size 这个参数**。

<font color=red>总结来说：</font> Redis 的主从库同步的基本原理有三种模式：全量复制、基于长连接的命令传播、增量复制。

##### 提问：

- AOF 记录的操作命令更全，相比于 RDB 丢失的数据更少。那么，为什么主从库间的复制不使用 AOF 呢？
  - <font color=blue>RDB文件内容是经过压缩的二进制数据，文件很小</font>。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，<font color=blue>传输RDB文件可以尽量降低对主库网络带宽的消耗</font>，从库在加载RDB文件时，一是**文件小，读取整个文件的速度会很快**，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析**还原数据即可**，速度会非常快，而**AOF需要依次重放每个写命令**，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低。
  - 假设要使用AOF做全量同步，意味着必须打开AOF功能，**打开AOF就要选择文件刷盘的策略**，选择不当会严重影响Redis性能

