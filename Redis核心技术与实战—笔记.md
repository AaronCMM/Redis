<img src="https://i.loli.net/2021/05/03/xyLUhvRasfdKNz4.jpg" alt="img" style="zoom: 18%;" />

Redis 使用哈希表来存储所有的键值对。

哈希桶中的 entry 元素中保存了 key 和 value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 value 指针被查找到。

<img src="https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg" alt="img" style="zoom: 33%;" />

##### 问题：

（1）	整数数组 和 压缩列表 在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

==两方面原因：==

1、内存利用率，**数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少**。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，**提高内存的利用率**。

2、**数组对CPU高速缓存支持更友好**，所以Redis在设计时，集合数据元素较少情况下，**默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度**。当**数据元素超过设定阈值**后，避免查询时间复杂度太高，**转为哈希和跳表数据结构存储**，保证查询效率。

##### （2）Redis 什么时候做 rehash？

Redis 会使用<font color=blue>装载因子来判断是否需要做 rehash</font>。

> 装载因子 = 哈希表中所有 entry 的个数 /  哈希桶个数

（3）采用渐进式 hash 时，如果实例暂时没有收到新请求，是不是就不做 rehash 了？

Redis 会执行定时任务，定时任务中就包含了 rehash 操作



### （一）为什么单线程的 Redis 能那么快？

Redis 是单线程的意思是：<font color=red>Redis 的网络 IO 和键值对读写是由一个线程来完成的</font>，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

#### 1、多线程的开销

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。

通常情况下，在我们采用多线程后，如果没有良好的系统设计，实际得到的结果，其实是右图所展示的那样。我们刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。

<img src="https://static001.geekbang.org/resource/image/cb/33/cbd394e62219cc5a6d9ae64035e51733.jpg" alt="img" style="zoom:30%;" />



<font color=red>**关键的瓶颈在于**</font>，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当**有多个线程要修改这个共享资源**时，为了保证共享资源的正确性，就需要有**额外的机制进行保证**，而这个额外的机制，就会**带来额外的开销**。**==多线程编程模式面临的共享资源的并发访问控制问题。==**

并发访问控制一直是多线程开发中的一个难点问题，**如果没有精细的设计，**比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：**即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加**。而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。**为了避免这些问题，Redis 直接采用了单线程模式。**

#### 2、单线程 Redis 为什么那么快？

- 一方面，<font color=red>**Redis 的大部分操作在内存上完成**</font>，再加上它采用了**高效的数据结构**，例如哈希表和跳表，这是它实现高性能的一个重要原因。
- 另一方面， <font color=red>**Redis 采用了多路IO复用机制**</font>，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。接下来，我们就重点学习下多路复用机制。

<img src="https://i.loli.net/2021/05/04/nJE1KcG3f9DSVvt.jpg" alt="img" style="zoom:20%;" />

Redis IO 多路复用机制： 

1. 基于linux select/epoll 。
2. 内核可同时监听多个监听套接字和 多个已连接套接字 。
3. 一旦内核监听到套接字上有数据返回，立刻交给redis线程处理数据。

##### 3、总结：

<font size=4>**Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题**</font>。单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。

<font size=4 color=blue>问题：</font>

- redis真的只有单线程吗？
  - 单线程是指网络IO 和数据读写操作是由一个线程完成的。**数据清理，持久化，主从复制也使用到了其他线程。** 

- 为什么使用单线程？ 
  - 避免多线程开发的并发控制问题，且多线程开发代码复杂，可维护性差。 
- 单线程为什么这么快？ 
  - 内存+高效的数据结构+IO 多路复用

##### 4、 有哪些潜在的性能瓶颈吗？

- <font color=blue>任意一个请求在server中一旦发生耗时，都会影响整个server的性能</font>，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：
  - **操作bigkey**：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；
  - 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
  - **大量key集中过期：Redis的过期机制也是在主线程中执行的**，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
  - **淘汰策略：淘汰策略也是在主线程执行的**，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
  - **AOF刷盘开启always机制**：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
  - **主从全量同步生成RDB**：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
- **并发量非常大时，单线程读写客户端IO数据存在性能瓶颈**，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，**只能单线程依次读取客户端的数据，无法利用到CPU多核。**

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了**lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。**

**针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据**，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。



### （二）AOF 日志是如何实现的？

传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。

##### 1、AOF 为什么要先执行命令再记日志呢？

为了避免额外的检查开销**，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查**。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。（可以避免出现记录错误命令的情况；不会阻塞当前的写操作。）

##### 2、AOF 的写回策略

<img src="https://i.loli.net/2021/05/04/2xnAm8fLIbuyNEc.jpg" alt="img" style="zoom:25%;" />

<font color=red>总结一下就是</font>：想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择 Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。

<font size=4>三种写回策略体现了系统设计中的一个重要原则 ，即<font color=red> trade-off</font>，或者称为“取舍”，指的就是在性能和可靠性保证之间做取舍。</font>

##### 3、日志文件太大了怎么办？（AOF重写机制）

**AOF 重写机制。**AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，**记录键值对的最终状态**，**从而实现对 某个键值对 重复操作后产生的多条操作记录压缩成一条 的效果**。进而实现压缩AOF文件的大小。

##### 4、AOF 重写会阻塞吗?

**和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的**，这也是为了避免阻塞主线程，导致数据库性能下降。

“一个拷贝，两处日志”。

“一个拷贝”是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。

因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志；第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作

<img src="https://i.loli.net/2021/05/04/89DMhHxYOVXtvr3.jpg" alt="img" style="zoom:20%;" />

<font color=red>总结来说</font>，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 **Redis 采用额外的线程进行数据重写**，所以，这个过程并不会阻塞主线程。

##### 5、问题：

- <font color=blue>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？</font>
  - AOF重写不复用AOF本身的日志，一个原因是**父子进程写同一个文件必然会产生竞争问题**，控制竞争就意味着会影响父进程的性能。**二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用**。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。

### （三）内存快照 RDB

<font color=red>写时复制，保证快照期间数据可修改。</font>

<img src="https://i.loli.net/2021/05/04/64EZMloYh8TbU2u.jpg" alt="img" style="zoom:15%;" />

bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，**如果主线程要修改一块数据**（例如图中的键值对 C），那么，**这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件**，而在这个过程中，主线程仍然可以直接修改原来的数据。

##### 1、可以每秒做一次快照吗？

- 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
- bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，**fork 这个创建过程本身会阻塞主线程，**而且主线程的内存越大，阻塞时间越长。

<font color=red>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法</font>。简单来说，<font size=4>**内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作**。</font>

内存快照和AOF混合使用：

<img src="https://static001.geekbang.org/resource/image/e4/20/e4c5846616c19fe03dbf528437beb320.jpg" alt="img" style="zoom:20%;" />

##### 2、问题

- 2核CPU、4GB内存、500G磁盘，Redis实例占用2GB，写读比例为8:2，此时做RDB持久化，有什么风险吗？

答：产生的风险主要在于 CPU资源 和 内存资源 这2方面：

a、内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，**“写实复制”会重新分配整个实例80%的内存副本**，大约需要重新分配1.6GB内存空间，这样**整个系统的内存使用接近饱和**，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。

### （四）主从库如何实现数据一致？

学习了 AOF 和 RDB，如果 Redis 发生了宕机，它们可以分别通过回放日志和重新读入 RDB 文件的方式恢复数据，从而保证尽量少丢失数据，提升可靠性。

##### 1、Redis 的高可靠性

- 数据尽量少丢失。
- **服务尽量少中断。**

AOF 和 RDB 文件保证了前者，对于后者，Redis 的做法是，**增加副本冗余余量**。

<font color=red>Redis 主从库和读写分离：</font>

<img src="https://static001.geekbang.org/resource/image/80/2f/809d6707404731f7e493b832aa573a2f.jpg" alt="img" style="zoom: 18%;" />

使用读写分离，对于写操作，首先在主库执行，然后主库将写操作同步到从库。这么做 的原因在于，不需要涉及到 加锁、实例间协商是否完成修改等系列操作。

#### 2、主从库间如何进行第一次同步？

当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系。

<img src="https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg" alt="img" style="zoom:18%;" />

FULLRESYNC 响应表示**第一次复制采用的全量复制**，主库会把当前所有的数据都复制给从库。在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。

**主库执行 bgsave 命令，生成 RDB 文件**，生成一个子进程，将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。为了保证主从库的数据一致性，主库会在内存中用专门的 **replication buffer，记录 RDB 文件生成后收到的所有写操作。**

#### 3、主从级联模式分担全量复制时的主库压力

一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。**如果从库数量很多**，而且都要和主库进行全量复制的话，**就会导致主库忙于 fork 子进程**生成 RDB 文件，进行数据全量同步。**fork 这个操作会阻塞主线程**处理正常请求

通过<font color=red>“主 - 从 - 从”模式</font>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。

<img src="https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg" alt="img" style="zoom:15%;" />

#### 4、主从库间网络断了怎么办？

当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。

<font color=red>repl_backlog_buffer 是一个环形缓冲区（全局共享）</font>，主库会记录自己写到的位置，从库会记录自己已经读到的位置。

<img src="https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg" alt="img" style="zoom:15%;" />

**主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库**；主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距，并进行增量复制。

**如果从库的读取速度比较慢**，就有可能导致**从库还未读取的操作被主库新写的操作覆盖了**，这会导致主从库间的数据不一致。（此时会变成，**全量复制**）；要想办法避免这一情况，一般而言，我们**可以调整 repl_backlog_size 这个参数**。

<font color=red>总结来说：</font> Redis 的主从库同步的基本原理有三种模式：全量复制、基于长连接的命令传播、增量复制。

##### 5、 提问：

- AOF 记录的操作命令更全，相比于 RDB 丢失的数据更少。那么，为什么主从库间的复制不使用 AOF 呢？
  - <font color=blue>RDB文件内容是经过压缩的二进制数据，文件很小</font>。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，<font color=blue>传输RDB文件可以尽量降低对主库网络带宽的消耗</font>，从库在加载RDB文件时，一是**文件小，读取整个文件的速度会很快**，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析**还原数据即可**，速度会非常快，而**AOF需要依次重放每个写命令**，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低。
  - 假设要使用AOF做全量同步，意味着必须打开AOF功能，**打开AOF就要选择文件刷盘的策略**，选择不当会严重影响Redis性能



### （五）哨兵机制：主库挂了，如何不间断服务？

#### 1、基本流程：

​		**哨兵其实就是一个运行在特殊模式下的 Redis 进程**，主从库实例运行的同时，它也在运行。<font color=blue>哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</font>

​		监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”。

​		在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。

在监控和选主这两个任务中，哨兵需要做出两个决策：

- 在监控任务中，**哨兵需要判断主库是否处于下线状态**；
- 在选主任务中，哨兵也要**决定选择哪个从库实例作为主库**。

#### 2、主观下线和客观下线

哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。**如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。**

为了避免单个哨兵对 主库状态进行误判，引入哨兵集群，一起做决策。

在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”。客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”

#### 3、如何选定新主库？

筛选 + 打分

除了检查从库的当前在线状态，还要判断它之前的网络连接状态；如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。

<font color=red>使用配置项 down-after-milliseconds * 10</font>。其中，down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。

<font color=red>从库优先级、从库复制进度以及从库 ID 号</font>；从这三方面对从库进行打分；

#### 4、提问：

**4.1 在主从库切换过程中，客户端能否正常地进行请求操作吗？**

> **如果客户端使用了读写分离**，那么**读请求可以在从库上正常执行**，不会受到影响。但是由于此时主库已经挂了，而且哨兵还没有选出新的主库，所以**在这期间写请求会失败**，失败持续的时间 = 哨兵切换主从的时间 + 客户端感知到新主库 的时间。

**4.2 如果想要应用程序不感知服务的中断，还需要哨兵或需要客户端再做些什么吗？**

> 当哨兵完成主从切换后，客户端需要及时感知到主库发生了变更，然后把缓存的写请求写入到新库中，保证后续写请求不会再受到影响，具体做法如下：
>
> 哨兵提升一个从库为新主库后，哨兵会把新主库的地址写入自己实例的pubsub（switch-master）中。**客户端需要订阅这个pubsub**，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址，然后把写请求写到这个新主库即可，**这种机制属于哨兵主动通知客户端**。
>
> 

### （六）哨兵集群：哨兵挂了，主从库还能切换吗？

**实际上，一旦多个实例组成了哨兵集群，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作**，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端

==哨兵的配置信息：==

```
sentinel monitor <master-name> <ip> <redis-port> <quorum> 
```

#### 1、基于 pub/sub 机制的哨兵集群组成

哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/sub 机制（发布 / 订阅机制）

**哨兵**只要和主库建立起了连接，就**可以在主库上发布消息**了，比如说**发布它自己的连接信息（IP 和端口）**。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。

为了<font color=blue>区分不同应用的消息</font>，Redis 会<font color=blue>以频道的形式</font>，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。

哨兵通过在 <font color=red>“ sentinel:hello ”</font>频道上订阅和发布连接信息，来和集群上的所有哨兵通信。

<img src="https://i.loli.net/2021/05/16/Y4iXVwakWScZDhK.jpg" alt="img" style="zoom:20%;" />

哨兵除了彼此之间建立起连接形成集群外，<font color=blue>还需要和从库建立连接</font>。这是因为，在哨兵的监控任务中，<font color=blue>它需要对主从库都进行心跳判断，而且在主从库切换完成后，它还需要通知从库</font>，让它们和新主库进行同步。

#### 2、哨兵如何知道从库的 IP 地址和端口？

由哨兵向主库发送 INFO 命令来完成；收到 INFO 命令的主库，会把从库列表信息返回给哨兵；

<font color=purple size=4>总结：</font>通过 pub/sub 机制，哨兵之间可以组成集群，同时，哨兵又通过 INFO 命令，获得了从库连接信息，从而和从库建立连接，并进行监控。

#### 3、基于 pub/sub 机制的客户端事件通知

从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例；每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。

<img src="https://static001.geekbang.org/resource/image/4e/25/4e9665694a9565abbce1a63cf111f725.jpg" alt="img" style="zoom:20%;" />

客户端读取哨兵的配置文件后，就可以获得哨兵的地址和端口，从而和哨兵建立网络连接，然后从哨兵这订阅不同的事件。

#### 4、由哪个哨兵执行主从切换？

<font color=red size=4>投票仲裁；</font>

任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应。**一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”**。这个<font color=red size=4>所需的赞成票数</font>是通过哨兵配置文件中的 <font color=red size=4>quorum 配置项</font>设定的。

此时（这个哨兵获得一半以上的赞成票后，标记主库为“客观下线”），这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为<font color=red>“Leader 选举”</font>。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。

需要注意的是，**如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的**。因此，通常我们至少会配置 3 个哨兵实例。

#### 5、总结

我们在解决一个系统问题的时候，会引入一个新机制，或者设计一层新功能；为了实现主从切换，我们引入了哨兵；为了避免单个哨兵故障后无法进行主从切换，以及为了减少误判率，又引入了哨兵集群；哨兵集群又需要有一些机制来支撑它的正常运行。

- 基于 pub/sub 机制的哨兵集群组成过程；
- 基于 INFO 命令的从库列表，这可以帮助哨兵和从库建立连接；
- 基于哨兵自身的 pub/sub 功能，这实现了客户端和哨兵之间的事件通知。

#### 6、提问

<font size=4 color=red>6.1</font> 假设有一个 Redis 集群，是“一主四从”，同时配置了包含 **5 个哨兵实例**的集群，**quorum 值设为 2。**在运行过程中，如果**有 3 个哨兵实例都发生故障**了，此时，Redis 主库如果有故障**，还能正确地判断主库“客观下线”吗?**

> 哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，**哨兵集群可以判定主库为“客观下线”**。

<font size=4 color=red>6.2</font> 如果可以的话，还能进行主从库自动切换吗？

> 但**哨兵不能完成主从切换**。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到多数选票的结果。

<font size=4 color=red>6.3</font> 哨兵实例是不是越多越好呢，如果同时调大 down-after-milliseconds 值，对减少误判是不是也有好处呢？

> 哨兵在判定“主观下线”和选举“哨兵领导者”时，都需要和其他节点进行通信，交换信息，哨兵实例越多，通信的次数也就越多，而且部署多个哨兵时，会分布在不同机器上，节点越多带来的机器故障风险也会越大，这些问题都会影响到哨兵的通信和选举，出问题时也就意味着选举时间会变长，切换主从的时间变久。

### （七）切片集群：数据增加了，是该加内存还是加实例？

概念： 切片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。

#### 1、如何保存更多数据？

Redis 应对数据量增多的两种方案：<font color=red>纵向扩展；横向扩展</font>。

- 纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。(纵向扩展会受到硬件和成本的限制)
- 横向扩展：横向增加当前 Redis 实例的个数。（切片集群的管理）

#### 2、数据切片和实例的对应分布关系

Redis Cluster 方案采用<font color=red>哈希槽（Hash Slot）</font>，来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

具体的映射过程：

1. 首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；
2. 然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

##### 2.1  哈希槽 如何和实例关联上？

- 在部署 Redis Cluster 方案时，可以使用<font color=blue> cluster create</font> 创建集群，此时，Redis 会自动把这些槽<font color=blue>平均分布</font>在集群实例上。

- 可以使用 <font color=blue>cluster meet</font> 命令手动建立实例间的连接，形成集群，<font color=blue>再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。</font>

数据、哈希槽、实例这三者的映射分布情况：

<img src="https://i.loli.net/2021/05/12/9tlJbDUI31YP8M6.jpg" alt="img" style="zoom:20%;" />

```
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```

NOTE：<font color=red>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</font>

##### 2.2 客户端如何定位数据

Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，<font color=blue>每个实例就有所有哈希槽的映射关系</font>了。

<font color=blue>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地</font>。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

#### 3、重定向机制

- 在集群中，当实例有新增或删除时，Redis 都需要重新分配哈希槽；
- 或者为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。

以上两种情况将导致哈希槽和实例间的对应关系发生变化，实例间可以通过相互交换信息得知。而客户端，则通过 重定向机制得知 映射关系发生了变化。

Redis Cluster 方案提供了一种重定向机制，**所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令**。

##### 3.1 MOVED 命令（数据已经全部迁移到另一个实例）

具体地：当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。<font color=red>同时根据 MOVED 命令，更新本地缓存</font>

```
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
# MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。
```

##### 3.2 ASK命令（部分数据正在迁移，一部分在原实例，另一部分在 新实例上）

```
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```

这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个**哈希槽正在迁移**。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。

> ASK 命令表示两层含义：**第一，表明 Slot 数据还在迁移中**；第二，**ASK 命令把客户端所请求数据的最新实例地址返回给客户端**，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。

<font color=red>和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。</font>

## [ 实践篇 ]

